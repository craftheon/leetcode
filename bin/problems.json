[{"id":"1","slug":"two-sum","title":"Two Sum","difficulty":"Easy","content":"Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.You may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.You can return the answer in any order.\n\n**Example 1:**```javascript \n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n```**Example 2:**```javascript \n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n```**Example 3:**```javascript \n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]\n```\n\n**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?","hints":["A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.","So, if we fix one of the numbers, say `x`, we have to scan the entire array to find the next number `y` which is `value - x` where value is the input parameter. Can we change our array somehow so that this search becomes faster?","The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"],"similars":[{"title":"3Sum","slug":"3sum","difficulty":"Medium"},{"title":"4Sum","slug":"4sum","difficulty":"Medium"},{"title":"Two Sum II - Input Array Is Sorted","slug":"two-sum-ii-input-array-is-sorted","difficulty":"Medium"},{"title":"Two Sum III - Data structure design","slug":"two-sum-iii-data-structure-design","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"}]},{"id":"2","slug":"add-two-numbers","title":"Add Two Numbers","difficulty":"Medium","content":"You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)```javascript \nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n```\n\n**Example 2:**\n\n```javascript \nInput: l1 = [0], l2 = [0]\nOutput: [0]\n```\n\n**Example 3:**\n\n```javascript \nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n```\n\n**Constraints:**\n\n*   The number of nodes in each linked list is in the range `[1, 100]`.\n*   `0 <= Node.val <= 9`\n*   It is guaranteed that the list represents a number that does not have leading zeros.","hints":[],"similars":[{"title":"Multiply Strings","slug":"multiply-strings","difficulty":"Medium"},{"title":"Add Binary","slug":"add-binary","difficulty":"Easy"},{"title":"Sum of Two Integers","slug":"sum-of-two-integers","difficulty":"Medium"},{"title":"Add Strings","slug":"add-strings","difficulty":"Easy"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Math","slug":"math"},{"name":"Recursion","slug":"recursion"}]},{"id":"3","slug":"longest-substring-without-repeating-characters","title":"Longest Substring Without Repeating Characters","difficulty":"Medium","content":"Given a string `s`, find the length of the **longest** **substring** without repeating characters.\n\n**Example 1:**\n\n```javascript \nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```\n\n**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of English letters, digits, symbols and spaces.","hints":[],"similars":[{"title":"Longest Substring with At Most Two Distinct Characters","slug":"longest-substring-with-at-most-two-distinct-characters","difficulty":"Medium"},{"title":"Longest Substring with At Most K Distinct Characters","slug":"longest-substring-with-at-most-k-distinct-characters","difficulty":"Medium"},{"title":"Subarrays with K Different Integers","slug":"subarrays-with-k-different-integers","difficulty":"Hard"},{"title":"Maximum Erasure Value","slug":"maximum-erasure-value","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Sliding Window","slug":"sliding-window"}]},{"id":"4","slug":"median-of-two-sorted-arrays","title":"Median of Two Sorted Arrays","difficulty":"Hard","content":"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n**Example 1:**\n\n```javascript \nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```\n\n**Constraints:**\n\n*   `nums1.length == m`\n*   `nums2.length == n`\n*   `0 <= m <= 1000`\n*   `0 <= n <= 1000`\n*   `1 <= m + n <= 2000`\n*   `-106 <= nums1[i], nums2[i] <= 106`","hints":[],"similars":[{"title":"Median of a Row Wise Sorted Matrix","slug":"median-of-a-row-wise-sorted-matrix","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Binary Search","slug":"binary-search"},{"name":"Divide and Conquer","slug":"divide-and-conquer"}]},{"id":"5","slug":"longest-palindromic-substring","title":"Longest Palindromic Substring","difficulty":"Medium","content":"Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.\n\n**Example 1:**\n\n```javascript \nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"cbbd\"\nOutput: \"bb\"\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consist of only digits and English letters.","hints":["How can we reuse a previously computed palindrome to compute a larger palindrome?","If “aba” is a palindrome, is “xabax” a palindrome? Similarly is “xabay” a palindrome?","Complexity based hint:  \nIf we use brute-force and check whether for every start and end position a substring is a palindrome we have O(n^2) start - end pairs and O(n) palindromic checks. Can we reduce the time for palindromic checks to O(1) by reusing some previous computation."],"similars":[{"title":"Shortest Palindrome","slug":"shortest-palindrome","difficulty":"Hard"},{"title":"Palindrome Permutation","slug":"palindrome-permutation","difficulty":"Easy"},{"title":"Palindrome Pairs","slug":"palindrome-pairs","difficulty":"Hard"},{"title":"Longest Palindromic Subsequence","slug":"longest-palindromic-subsequence","difficulty":"Medium"}],"tags":[{"name":"String","slug":"string"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"6","slug":"zigzag-conversion","title":"Zigzag Conversion","difficulty":"Medium","content":"The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n```javascript \nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\n```javascript \nstring convert(string s, int numRows);\n```\n\n**Example 1:**\n\n```javascript \nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.\n*   `1 <= numRows <= 1000`","hints":[],"similars":[],"tags":[{"name":"String","slug":"string"}]},{"id":"7","slug":"reverse-integer","title":"Reverse Integer","difficulty":"Medium","content":"Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**\n\n**Example 1:**\n\n```javascript \nInput: x = 123\nOutput: 321\n```\n\n**Example 2:**\n\n```javascript \nInput: x = -123\nOutput: -321\n```\n\n**Example 3:**\n\n```javascript \nInput: x = 120\nOutput: 21\n```\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`","hints":[],"similars":[{"title":"String to Integer (atoi)","slug":"string-to-integer-atoi","difficulty":"Medium"},{"title":"Reverse Bits","slug":"reverse-bits","difficulty":"Easy"},{"title":"A Number After a Double Reversal","slug":"a-number-after-a-double-reversal","difficulty":"Easy"},{"title":"Count Number of Distinct Integers After Reverse Operations","slug":"count-number-of-distinct-integers-after-reverse-operations","difficulty":"Medium"}],"tags":[{"name":"Math","slug":"math"}]},{"id":"9","slug":"palindrome-number","title":"Palindrome Number","difficulty":"Easy","content":"Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.\n\n**Example 1:**\n\n```javascript \nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n```\n\n**Example 2:**\n\n```javascript \nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n```\n\n**Example 3:**\n\n```javascript \nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n```\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**Follow up:** Could you solve it without converting the integer to a string?","hints":["Beware of overflow when you reverse the integer."],"similars":[{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Find Palindrome With Fixed Length","slug":"find-palindrome-with-fixed-length","difficulty":"Medium"},{"title":"Strictly Palindromic Number","slug":"strictly-palindromic-number","difficulty":"Medium"},{"title":"  Count Symmetric Integers","slug":"count-symmetric-integers","difficulty":"Easy"}],"tags":[{"name":"Math","slug":"math"}]},{"id":"11","slug":"container-with-most-water","title":"Container With Most Water","difficulty":"Medium","content":"You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)```javascript \nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n```\n\n**Example 2:**\n\n```javascript \nInput: height = [1,1]\nOutput: 1\n```\n\n**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`","hints":["If you simulate the problem, it will be O(n^2) which is not efficient.","Try to use two-pointers. Set one pointer to the left and one to the right of the array. Always move the pointer that points to the lower line.","How can you calculate the amount of water at each step?"],"similars":[{"title":"Trapping Rain Water","slug":"trapping-rain-water","difficulty":"Hard"},{"title":"Maximum Tastiness of Candy Basket","slug":"maximum-tastiness-of-candy-basket","difficulty":"Medium"},{"title":"House Robber IV","slug":"house-robber-iv","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Greedy","slug":"greedy"}]},{"id":"12","slug":"integer-to-roman","title":"Integer to Roman","difficulty":"Medium","content":"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n```javascript \nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000```\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\n**Example 1:**\n\n```javascript \nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\n```\n\n**Example 2:**\n\n```javascript \nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\n```\n\n**Example 3:**\n\n```javascript \nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n**Constraints:**\n\n*   `1 <= num <= 3999`","hints":[],"similars":[{"title":"Roman to Integer","slug":"roman-to-integer","difficulty":"Easy"},{"title":"Integer to English Words","slug":"integer-to-english-words","difficulty":"Hard"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Math","slug":"math"},{"name":"String","slug":"string"}]},{"id":"13","slug":"roman-to-integer","title":"Roman to Integer","difficulty":"Easy","content":"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n```javascript \nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000```\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.\n\n**Example 1:**\n\n```javascript \nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.","hints":["Problem is simpler to solve by working the string from back to front and using a map."],"similars":[{"title":"Integer to Roman","slug":"integer-to-roman","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Math","slug":"math"},{"name":"String","slug":"string"}]},{"id":"14","slug":"longest-common-prefix","title":"Longest Common Prefix","difficulty":"Easy","content":"Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\"\"`.\n\n**Example 1:**\n\n```javascript \nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n```\n\n**Example 2:**\n\n```javascript \nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n```\n\n**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` consists of only lowercase English letters.","hints":[],"similars":[],"tags":[{"name":"String","slug":"string"},{"name":"Trie","slug":"trie"}]},{"id":"15","slug":"3sum","title":"3Sum","difficulty":"Medium","content":"Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.Notice that the solution set must not contain duplicate triplets.\n\n**Example 1:**```javascript \n**Input:** nums = \\[-1,0,1,2,-1,-4\\]\n**Output:** \\[\\[-1,-1,2\\],\\[-1,0,1\\]\\]\n**Explanation:** \nnums\\[0\\] + nums\\[1\\] + nums\\[2\\] = (-1) + 0 + 1 = 0.\nnums\\[1\\] + nums\\[2\\] + nums\\[4\\] = 0 + 1 + (-1) = 0.\nnums\\[0\\] + nums\\[3\\] + nums\\[4\\] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are \\[-1,0,1\\] and \\[-1,-1,2\\].\nNotice that the order of the output and the order of the triplets does not matter.\n```**Example 2:**```javascript \n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[\\]\n**Explanation:** The only possible triplet does not sum up to 0.\n```**Example 3:**```javascript \n**Input:** nums = \\[0,0,0\\]\n**Output:** \\[\\[0,0,0\\]\\]\n**Explanation:** The only possible triplet sums up to 0.\n```\n\n**Constraints:**\n\n*   `3 <= nums.length <= 3000`\n*   `-105 <= nums[i] <= 105`","hints":["So, we essentially need to find three numbers x, y, and z such that they add up to the given value. If we fix one of the numbers say x, we are left with the two-sum problem at hand!","For the two-sum problem, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y, which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?","The second train of thought for two-sum is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"],"similars":[{"title":"Two Sum","slug":"two-sum","difficulty":"Easy"},{"title":"3Sum Closest","slug":"3sum-closest","difficulty":"Medium"},{"title":"4Sum","slug":"4sum","difficulty":"Medium"},{"title":"3Sum Smaller","slug":"3sum-smaller","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Sorting","slug":"sorting"}]},{"id":"16","slug":"3sum-closest","title":"3Sum Closest","difficulty":"Medium","content":"Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.\n\n**Example 1:**\n\n```javascript \nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n```\n\n**Constraints:**\n\n*   `3 <= nums.length <= 500`\n*   `-1000 <= nums[i] <= 1000`\n*   `-104 <= target <= 104`","hints":[],"similars":[{"title":"3Sum","slug":"3sum","difficulty":"Medium"},{"title":"3Sum Smaller","slug":"3sum-smaller","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Sorting","slug":"sorting"}]},{"id":"17","slug":"letter-combinations-of-a-phone-number","title":"Letter Combinations of a Phone Number","difficulty":"Medium","content":"Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n![](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)\n\n**Example 1:**\n\n```javascript \nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:**\n\n```javascript \nInput: digits = \"\"\nOutput: []\n```\n\n**Example 3:**\n\n```javascript \nInput: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n```\n\n**Constraints:**\n\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.","hints":[],"similars":[{"title":"Generate Parentheses","slug":"generate-parentheses","difficulty":"Medium"},{"title":"Combination Sum","slug":"combination-sum","difficulty":"Medium"},{"title":"Binary Watch","slug":"binary-watch","difficulty":"Easy"},{"title":"Count Number of Texts","slug":"count-number-of-texts","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Backtracking","slug":"backtracking"}]},{"id":"19","slug":"remove-nth-node-from-end-of-list","title":"Remove Nth Node From End of List","difficulty":"Medium","content":"Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)```javascript \nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:**\n\n```javascript \nInput: head = [1], n = 1\nOutput: []\n```\n\n**Example 3:**\n\n```javascript \nInput: head = [1,2], n = 1\nOutput: [1]\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is `sz`.\n*   `1 <= sz <= 30`\n*   `0 <= Node.val <= 100`\n*   `1 <= n <= sz`\n\n**Follow up:** Could you do this in one pass?","hints":["Maintain two pointers and update one with a delay of n steps."],"similars":[{"title":"Swapping Nodes in a Linked List","slug":"swapping-nodes-in-a-linked-list","difficulty":"Medium"},{"title":"Delete N Nodes After M Nodes of a Linked List","slug":"delete-n-nodes-after-m-nodes-of-a-linked-list","difficulty":"Easy"},{"title":"Delete the Middle Node of a Linked List","slug":"delete-the-middle-node-of-a-linked-list","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"22","slug":"generate-parentheses","title":"Generate Parentheses","difficulty":"Medium","content":"Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.\n\n**Example 1:**\n\n```javascript \nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 1\nOutput: [\"()\"]\n```\n\n**Constraints:**\n\n*   `1 <= n <= 8`","hints":[],"similars":[{"title":"Letter Combinations of a Phone Number","slug":"letter-combinations-of-a-phone-number","difficulty":"Medium"},{"title":"Valid Parentheses","slug":"valid-parentheses","difficulty":"Easy"},{"title":"Check if a Parentheses String Can Be Valid","slug":"check-if-a-parentheses-string-can-be-valid","difficulty":"Medium"}],"tags":[{"name":"String","slug":"string"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Backtracking","slug":"backtracking"}]},{"id":"25","slug":"reverse-nodes-in-k-group","title":"Reverse Nodes in k-Group","difficulty":"Hard","content":"Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return _the modified list_.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)```javascript \nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)```javascript \nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= k <= n <= 5000`\n*   `0 <= Node.val <= 1000`\n\n**Follow-up:** Can you solve the problem in `O(1)` extra memory space?","hints":[],"similars":[{"title":"Swap Nodes in Pairs","slug":"swap-nodes-in-pairs","difficulty":"Medium"},{"title":"Swapping Nodes in a Linked List","slug":"swapping-nodes-in-a-linked-list","difficulty":"Medium"},{"title":"Reverse Nodes in Even Length Groups","slug":"reverse-nodes-in-even-length-groups","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Recursion","slug":"recursion"}]},{"id":"27","slug":"remove-element","title":"Remove Element","difficulty":"Easy","content":"Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\n```javascript \nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n```javascript \nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Constraints:**\n\n*   `0 <= nums.length <= 100`\n*   `0 <= nums[i] <= 50`\n*   `0 <= val <= 100`","hints":["The problem statement clearly asks us to modify the array in-place and it also says that the element beyond the new length of the array can be anything. Given an element, we need to remove all the occurrences of it from the array. We don't technically need to **remove** that element per-say, right?","We can move all the occurrences of this element to the end of the array. Use two pointers!  \n![](https://assets.leetcode.com/uploads/2019/10/20/hint_remove_element.png)","Yet another direction of thought is to consider the elements to be removed as non-existent. In a single pass, if we keep copying the visible elements in-place, that should also solve this problem for us."],"similars":[{"title":"Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","difficulty":"Easy"},{"title":"Remove Linked List Elements","slug":"remove-linked-list-elements","difficulty":"Easy"},{"title":"Move Zeroes","slug":"move-zeroes","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"42","slug":"trapping-rain-water","title":"Trapping Rain Water","difficulty":"Hard","content":"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)```javascript \nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n\n```javascript \nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`","hints":[],"similars":[{"title":"Container With Most Water","slug":"container-with-most-water","difficulty":"Medium"},{"title":"Product of Array Except Self","slug":"product-of-array-except-self","difficulty":"Medium"},{"title":"Trapping Rain Water II","slug":"trapping-rain-water-ii","difficulty":"Hard"},{"title":"Pour Water","slug":"pour-water","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Stack","slug":"stack"},{"name":"Monotonic Stack","slug":"monotonic-stack"}]},{"id":"45","slug":"jump-game-ii","title":"Jump Game II","difficulty":"Medium","content":"You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n**Example 1:**\n\n```javascript \nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [2,3,0,1,4]\nOutput: 2\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.","hints":[],"similars":[{"title":"Jump Game","slug":"jump-game","difficulty":"Medium"},{"title":"Jump Game III","slug":"jump-game-iii","difficulty":"Medium"},{"title":"Jump Game VII","slug":"jump-game-vii","difficulty":"Medium"},{"title":"Jump Game VIII","slug":"jump-game-viii","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Greedy","slug":"greedy"}]},{"id":"46","slug":"permutations","title":"Permutations","difficulty":"Medium","content":"Given an array `nums` of distinct integers, return _all the possible permutations_. You can return the answer in **any order**.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [1]\nOutput: [[1]]\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 6`\n*   `-10 <= nums[i] <= 10`\n*   All the integers of `nums` are **unique**.","hints":[],"similars":[{"title":"Next Permutation","slug":"next-permutation","difficulty":"Medium"},{"title":"Permutations II","slug":"permutations-ii","difficulty":"Medium"},{"title":"Permutation Sequence","slug":"permutation-sequence","difficulty":"Hard"},{"title":"Combinations","slug":"combinations","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Backtracking","slug":"backtracking"}]},{"id":"48","slug":"rotate-image","title":"Rotate Image","difficulty":"Medium","content":"You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)```javascript \nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)```javascript \nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n```\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 20`\n*   `-1000 <= matrix[i][j] <= 1000`","hints":[],"similars":[{"title":"Determine Whether Matrix Can Be Obtained By Rotation","slug":"determine-whether-matrix-can-be-obtained-by-rotation","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Math","slug":"math"},{"name":"Matrix","slug":"matrix"}]},{"id":"51","slug":"n-queens","title":"N-Queens","difficulty":"Hard","content":"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)```javascript \nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 1\nOutput: [[\"Q\"]]\n```\n\n**Constraints:**\n\n*   `1 <= n <= 9`","hints":[],"similars":[{"title":"N-Queens II","slug":"n-queens-ii","difficulty":"Hard"},{"title":"Grid Illumination","slug":"grid-illumination","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Backtracking","slug":"backtracking"}]},{"id":"53","slug":"maximum-subarray","title":"Maximum Subarray","difficulty":"Medium","content":"Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.\n\n**Example 1:**\n\n```javascript \nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.","hints":[],"similars":[{"title":"Best Time to Buy and Sell Stock","slug":"best-time-to-buy-and-sell-stock","difficulty":"Easy"},{"title":"Maximum Product Subarray","slug":"maximum-product-subarray","difficulty":"Medium"},{"title":"Degree of an Array","slug":"degree-of-an-array","difficulty":"Easy"},{"title":"Longest Turbulent Subarray","slug":"longest-turbulent-subarray","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Divide and Conquer","slug":"divide-and-conquer"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"55","slug":"jump-game","title":"Jump Game","difficulty":"Medium","content":"You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n\n**Example 1:**\n\n```javascript \nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`","hints":[],"similars":[{"title":"Jump Game II","slug":"jump-game-ii","difficulty":"Medium"},{"title":"Jump Game III","slug":"jump-game-iii","difficulty":"Medium"},{"title":"Jump Game VII","slug":"jump-game-vii","difficulty":"Medium"},{"title":"Jump Game VIII","slug":"jump-game-viii","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Greedy","slug":"greedy"}]},{"id":"58","slug":"length-of-last-word","title":"Length of Last Word","difficulty":"Easy","content":"Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.\n\n**Example 1:**\n\n```javascript \nInput: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"   fly me   to   the moon  \"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only English letters and spaces `' '`.\n*   There will be at least one word in `s`.","hints":[],"similars":[],"tags":[{"name":"String","slug":"string"}]},{"id":"61","slug":"rotate-list","title":"Rotate List","difficulty":"Medium","content":"Given the `head` of a linked list, rotate the list to the right by `k` places.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)```javascript \nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)```javascript \nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 500]`.\n*   `-100 <= Node.val <= 100`\n*   `0 <= k <= 2 * 109`","hints":[],"similars":[{"title":"Rotate Array","slug":"rotate-array","difficulty":"Medium"},{"title":"Split Linked List in Parts","slug":"split-linked-list-in-parts","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"62","slug":"unique-paths","title":"Unique Paths","difficulty":"Medium","content":"There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)```javascript \nInput: m = 3, n = 7\nOutput: 28\n```\n\n**Example 2:**\n\n```javascript \nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n```\n\n**Constraints:**\n\n*   `1 <= m, n <= 100`","hints":[],"similars":[{"title":"Unique Paths II","slug":"unique-paths-ii","difficulty":"Medium"},{"title":"Minimum Path Sum","slug":"minimum-path-sum","difficulty":"Medium"},{"title":"Dungeon Game","slug":"dungeon-game","difficulty":"Hard"},{"title":"Minimum Path Cost in a Grid","slug":"minimum-path-cost-in-a-grid","difficulty":"Medium"}],"tags":[{"name":"Math","slug":"math"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Combinatorics","slug":"combinatorics"}]},{"id":"63","slug":"unique-paths-ii","title":"Unique Paths II","difficulty":"Medium","content":"You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)```javascript \nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)```javascript \nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n```\n\n**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.","hints":["Use dynamic programming since, from each cell, you can move to the right or down.","assume dp\\[i\\]\\[j\\] is the number of unique paths to reach (i, j). dp\\[i\\]\\[j\\] = dp\\[i\\]\\[j -1\\] + dp\\[i - 1\\]\\[j\\]. Be careful when you encounter an obstacle. set its value in dp to 0."],"similars":[{"title":"Unique Paths","slug":"unique-paths","difficulty":"Medium"},{"title":"Unique Paths III","slug":"unique-paths-iii","difficulty":"Hard"},{"title":"Minimum Path Cost in a Grid","slug":"minimum-path-cost-in-a-grid","difficulty":"Medium"},{"title":"Paths in Matrix Whose Sum Is Divisible by K","slug":"paths-in-matrix-whose-sum-is-divisible-by-k","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Matrix","slug":"matrix"}]},{"id":"64","slug":"minimum-path-sum","title":"Minimum Path Sum","difficulty":"Medium","content":"Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)```javascript \nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n```\n\n**Example 2:**\n\n```javascript \nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n```\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 200`","hints":[],"similars":[{"title":"Unique Paths","slug":"unique-paths","difficulty":"Medium"},{"title":"Dungeon Game","slug":"dungeon-game","difficulty":"Hard"},{"title":"Cherry Pickup","slug":"cherry-pickup","difficulty":"Hard"},{"title":"Minimum Path Cost in a Grid","slug":"minimum-path-cost-in-a-grid","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Matrix","slug":"matrix"}]},{"id":"72","slug":"edit-distance","title":"Edit Distance","difficulty":"Medium","content":"Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character\n\n**Example 1:**\n\n```javascript \nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:**\n\n```javascript \nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```\n\n**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.","hints":[],"similars":[{"title":"One Edit Distance","slug":"one-edit-distance","difficulty":"Medium"},{"title":"Delete Operation for Two Strings","slug":"delete-operation-for-two-strings","difficulty":"Medium"},{"title":"Minimum ASCII Delete Sum for Two Strings","slug":"minimum-ascii-delete-sum-for-two-strings","difficulty":"Medium"},{"title":"Uncrossed Lines","slug":"uncrossed-lines","difficulty":"Medium"}],"tags":[{"name":"String","slug":"string"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"80","slug":"remove-duplicates-from-sorted-array-ii","title":"Remove Duplicates from Sorted Array II","difficulty":"Medium","content":"Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_ `k` _slots of_ `nums`.\n\nDo **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\n```javascript \nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n```\n\nIf all assertions pass, then your solution will be **accepted**.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.","hints":[],"similars":[{"title":"Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"83","slug":"remove-duplicates-from-sorted-list","title":"Remove Duplicates from Sorted List","difficulty":"Easy","content":"Given the `head` of a sorted linked list, _delete all duplicates such that each element appears only once_. Return _the linked list **sorted** as well_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)```javascript \nInput: head = [1,1,2]\nOutput: [1,2]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)```javascript \nInput: head = [1,1,2,3,3]\nOutput: [1,2,3]\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 300]`.\n*   `-100 <= Node.val <= 100`\n*   The list is guaranteed to be **sorted** in ascending order.","hints":[],"similars":[{"title":"Remove Duplicates from Sorted List II","slug":"remove-duplicates-from-sorted-list-ii","difficulty":"Medium"},{"title":"Remove Duplicates From an Unsorted Linked List","slug":"remove-duplicates-from-an-unsorted-linked-list","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"}]},{"id":"86","slug":"partition-list","title":"Partition List","difficulty":"Medium","content":"Given the `head` of a linked list and a value `x`, partition it such that all nodes **less than** `x` come before nodes **greater than or equal** to `x`.\n\nYou should **preserve** the original relative order of the nodes in each of the two partitions.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)```javascript \nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n```\n\n**Example 2:**\n\n```javascript \nInput: head = [2,1], x = 2\nOutput: [1,2]\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 200]`.\n*   `-100 <= Node.val <= 100`\n*   `-200 <= x <= 200`","hints":[],"similars":[{"title":"Partition Array According to Given Pivot","slug":"partition-array-according-to-given-pivot","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"95","slug":"unique-binary-search-trees-ii","title":"Unique Binary Search Trees II","difficulty":"Medium","content":"Given an integer `n`, return _all the structurally unique **BST'**s (binary search trees), which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`. Return the answer in **any order**.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)```javascript \nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 1\nOutput: [[1]]\n```\n\n**Constraints:**\n\n*   `1 <= n <= 8`","hints":[],"similars":[{"title":"Unique Binary Search Trees","slug":"unique-binary-search-trees","difficulty":"Medium"},{"title":"Different Ways to Add Parentheses","slug":"different-ways-to-add-parentheses","difficulty":"Medium"}],"tags":[{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Backtracking","slug":"backtracking"},{"name":"Tree","slug":"tree"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"98","slug":"validate-binary-search-tree","title":"Validate Binary Search Tree","difficulty":"Medium","content":"Given the `root` of a binary tree, _determine if it is a valid binary search tree (BST)_.\n\nA **valid BST** is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)```javascript \nInput: root = [2,1,3]\nOutput: true\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)```javascript \nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`","hints":[],"similars":[{"title":"Binary Tree Inorder Traversal","slug":"binary-tree-inorder-traversal","difficulty":"Easy"},{"title":"Find Mode in Binary Search Tree","slug":"find-mode-in-binary-search-tree","difficulty":"Easy"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"101","slug":"symmetric-tree","title":"Symmetric Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)```javascript \nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)```javascript \nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Could you solve it both recursively and iteratively?","hints":[],"similars":[],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"103","slug":"binary-tree-zigzag-level-order-traversal","title":"Binary Tree Zigzag Level Order Traversal","difficulty":"Medium","content":"Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between).\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1]\nOutput: [[1]]\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Binary Tree Level Order Traversal","slug":"binary-tree-level-order-traversal","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"104","slug":"maximum-depth-of-binary-tree","title":"Maximum Depth of Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1,null,2]\nOutput: 2\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Balanced Binary Tree","slug":"balanced-binary-tree","difficulty":"Easy"},{"title":"Minimum Depth of Binary Tree","slug":"minimum-depth-of-binary-tree","difficulty":"Easy"},{"title":"Maximum Depth of N-ary Tree","slug":"maximum-depth-of-n-ary-tree","difficulty":"Easy"},{"title":"Time Needed to Inform All Employees","slug":"time-needed-to-inform-all-employees","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"106","slug":"construct-binary-tree-from-inorder-and-postorder-traversal","title":"Construct Binary Tree from Inorder and Postorder Traversal","difficulty":"Medium","content":"Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return _the binary tree_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)```javascript \nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:**\n\n```javascript \nInput: inorder = [-1], postorder = [-1]\nOutput: [-1]\n```\n\n**Constraints:**\n\n*   `1 <= inorder.length <= 3000`\n*   `postorder.length == inorder.length`\n*   `-3000 <= inorder[i], postorder[i] <= 3000`\n*   `inorder` and `postorder` consist of **unique** values.\n*   Each value of `postorder` also appears in `inorder`.\n*   `inorder` is **guaranteed** to be the inorder traversal of the tree.\n*   `postorder` is **guaranteed** to be the postorder traversal of the tree.","hints":[],"similars":[{"title":"Construct Binary Tree from Preorder and Inorder Traversal","slug":"construct-binary-tree-from-preorder-and-inorder-traversal","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"},{"name":"Divide and Conquer","slug":"divide-and-conquer"},{"name":"Tree","slug":"tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"107","slug":"binary-tree-level-order-traversal-ii","title":"Binary Tree Level Order Traversal II","difficulty":"Medium","content":"Given the `root` of a binary tree, return _the bottom-up level order traversal of its nodes' values_. (i.e., from left to right, level by level from leaf to root).\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1]\nOutput: [[1]]\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-1000 <= Node.val <= 1000`","hints":[],"similars":[{"title":"Binary Tree Level Order Traversal","slug":"binary-tree-level-order-traversal","difficulty":"Medium"},{"title":"Average of Levels in Binary Tree","slug":"average-of-levels-in-binary-tree","difficulty":"Easy"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"112","slug":"path-sum","title":"Path Sum","difficulty":"Easy","content":"Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.\n\nA **leaf** is a node with no children.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)```javascript \nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)```javascript \nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There two root-to-leaf paths in the tree:\n(1 --> 2): The sum is 3.\n(1 --> 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-1000 <= Node.val <= 1000`\n*   `-1000 <= targetSum <= 1000`","hints":[],"similars":[{"title":"Path Sum II","slug":"path-sum-ii","difficulty":"Medium"},{"title":"Binary Tree Maximum Path Sum","slug":"binary-tree-maximum-path-sum","difficulty":"Hard"},{"title":"Sum Root to Leaf Numbers","slug":"sum-root-to-leaf-numbers","difficulty":"Medium"},{"title":"Path Sum III","slug":"path-sum-iii","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"114","slug":"flatten-binary-tree-to-linked-list","title":"Flatten Binary Tree to Linked List","difficulty":"Medium","content":"Given the `root` of a binary tree, flatten the tree into a \"linked list\":\n\n*   The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n*   The \"linked list\" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)```javascript \nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n```\n\n**Example 2:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [0]\nOutput: [0]\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Can you flatten the tree in-place (with `O(1)` extra space)?","hints":["If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal."],"similars":[{"title":"Flatten a Multilevel Doubly Linked List","slug":"flatten-a-multilevel-doubly-linked-list","difficulty":"Medium"},{"title":"Correct a Binary Tree","slug":"correct-a-binary-tree","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Stack","slug":"stack"},{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"116","slug":"populating-next-right-pointers-in-each-node","title":"Populating Next Right Pointers in Each Node","difficulty":"Medium","content":"You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\n```javascript \nstruct Node {\n  int val;\n  Node left;\n  Node right;\n  Node next;\n}\n```\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)```javascript \nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n```\n\n**Example 2:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 212 - 1]`.\n*   `-1000 <= Node.val <= 1000`\n\n**Follow-up:**\n\n*   You may only use constant extra space.\n*   The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.","hints":[],"similars":[{"title":"Populating Next Right Pointers in Each Node II","slug":"populating-next-right-pointers-in-each-node-ii","difficulty":"Medium"},{"title":"Binary Tree Right Side View","slug":"binary-tree-right-side-view","difficulty":"Medium"},{"title":"Cycle Length Queries in a Tree","slug":"cycle-length-queries-in-a-tree","difficulty":"Hard"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"118","slug":"pascals-triangle","title":"Pascal's Triangle","difficulty":"Easy","content":"Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n**Example 1:**\n\n```javascript \nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n```\n\n**Example 2:**\n\n```javascript \nInput: numRows = 1\nOutput: [[1]]\n```\n\n**Constraints:**\n\n*   `1 <= numRows <= 30`","hints":[],"similars":[{"title":"Pascal's Triangle II","slug":"pascals-triangle-ii","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"120","slug":"triangle","title":"Triangle","difficulty":"Medium","content":"Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.\n\n**Example 1:**\n\n```javascript \nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n```\n\n**Example 2:**\n\n```javascript \nInput: triangle = [[-10]]\nOutput: -10\n```\n\n**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?","hints":[],"similars":[],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"121","slug":"best-time-to-buy-and-sell-stock","title":"Best Time to Buy and Sell Stock","difficulty":"Easy","content":"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n\n**Example 1:**\n\n```javascript \nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n```\n\n**Example 2:**\n\n```javascript \nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n```\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`","hints":[],"similars":[{"title":"Maximum Subarray","slug":"maximum-subarray","difficulty":"Medium"},{"title":"Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-ii","difficulty":"Medium"},{"title":"Best Time to Buy and Sell Stock III","slug":"best-time-to-buy-and-sell-stock-iii","difficulty":"Hard"},{"title":"Best Time to Buy and Sell Stock IV","slug":"best-time-to-buy-and-sell-stock-iv","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"125","slug":"valid-palindrome","title":"Valid Palindrome","difficulty":"Easy","content":"A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n**Example 1:**\n\n```javascript \nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.","hints":[],"similars":[{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Valid Palindrome II","slug":"valid-palindrome-ii","difficulty":"Easy"},{"title":"Maximum Product of the Length of Two Palindromic Subsequences","slug":"maximum-product-of-the-length-of-two-palindromic-subsequences","difficulty":"Medium"},{"title":"Find First Palindromic String in the Array","slug":"find-first-palindromic-string-in-the-array","difficulty":"Easy"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"139","slug":"word-break","title":"Word Break","difficulty":"Medium","content":"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n\n```javascript \nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.","hints":[],"similars":[{"title":"Word Break II","slug":"word-break-ii","difficulty":"Hard"},{"title":"Extra Characters in a String","slug":"extra-characters-in-a-string","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Trie","slug":"trie"},{"name":"Memoization","slug":"memoization"}]},{"id":"144","slug":"binary-tree-preorder-traversal","title":"Binary Tree Preorder Traversal","difficulty":"Easy","content":"Given the `root` of a binary tree, return _the preorder traversal of its nodes' values_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)```javascript \nInput: root = [1,null,2,3]\nOutput: [1,2,3]\n```\n\n**Example 2:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [1]\nOutput: [1]\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?","hints":[],"similars":[{"title":"Binary Tree Inorder Traversal","slug":"binary-tree-inorder-traversal","difficulty":"Easy"},{"title":"Verify Preorder Sequence in Binary Search Tree","slug":"verify-preorder-sequence-in-binary-search-tree","difficulty":"Medium"},{"title":"N-ary Tree Preorder Traversal","slug":"n-ary-tree-preorder-traversal","difficulty":"Easy"},{"title":"Kth Largest Sum in a Binary Tree","slug":"kth-largest-sum-in-a-binary-tree","difficulty":"Medium"}],"tags":[{"name":"Stack","slug":"stack"},{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"146","slug":"lru-cache","title":"LRU Cache","difficulty":"Medium","content":"Design a data structure that follows the constraints of a **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.\n\nImplement the `LRUCache` class:\n\n*   `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.\n*   `int get(int key)` Return the value of the `key` if the key exists, otherwise return `-1`.\n*   `void put(int key, int value)` Update the value of the `key` if the `key` exists. Otherwise, add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation, **evict** the least recently used key.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.\n\n**Example 1:**\n\n```javascript \nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n```\n\n**Constraints:**\n\n*   `1 <= capacity <= 3000`\n*   `0 <= key <= 104`\n*   `0 <= value <= 105`\n*   At most `2 * 105` calls will be made to `get` and `put`.","hints":[],"similars":[{"title":"LFU Cache","slug":"lfu-cache","difficulty":"Hard"},{"title":"Design In-Memory File System","slug":"design-in-memory-file-system","difficulty":"Hard"},{"title":"Design Compressed String Iterator","slug":"design-compressed-string-iterator","difficulty":"Easy"},{"title":"Design Most Recently Used Queue","slug":"design-most-recently-used-queue","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Linked List","slug":"linked-list"},{"name":"Design","slug":"design"},{"name":"Doubly-Linked List","slug":"doubly-linked-list"}]},{"id":"151","slug":"reverse-words-in-a-string","title":"Reverse Words in a String","difficulty":"Medium","content":"Given an input string `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.\n\nReturn _a string of the words in reverse order concatenated by a single space._\n\n**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n**Example 1:**\n\n```javascript \nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.\n*   There is **at least one** word in `s`.\n\n**Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?","hints":[],"similars":[{"title":"Reverse Words in a String II","slug":"reverse-words-in-a-string-ii","difficulty":"Medium"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"165","slug":"compare-version-numbers","title":"Compare Version Numbers","difficulty":"Medium","content":"Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`.\n\n**Example 1:**\n\n```javascript \nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\n```\n\n**Example 2:**\n\n```javascript \nInput: version1 = \"1.0\", version2 = \"1.0.0\"\nOutput: 0\nExplanation: version1 does not specify revision 2, which means it is treated as \"0\".\n```\n\n**Example 3:**\n\n```javascript \nInput: version1 = \"0.1\", version2 = \"1.1\"\nOutput: -1\nExplanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2.\n```\n\n**Constraints:**\n\n*   `1 <= version1.length, version2.length <= 500`\n*   `version1` and `version2` only contain digits and `'.'`.\n*   `version1` and `version2` **are valid version numbers**.\n*   All the given revisions in `version1` and `version2` can be stored in a **32-bit integer**.","hints":[],"similars":[],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"167","slug":"two-sum-ii-input-array-is-sorted","title":"Two Sum II - Input Array Is Sorted","difficulty":"Medium","content":"Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.\n\n**Example 1:**\n\n```javascript \nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n```\n\n**Example 2:**\n\n```javascript \nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n```\n\n**Example 3:**\n\n```javascript \nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n```\n\n**Constraints:**\n\n*   `2 <= numbers.length <= 3 * 104`\n*   `-1000 <= numbers[i] <= 1000`\n*   `numbers` is sorted in **non-decreasing order**.\n*   `-1000 <= target <= 1000`\n*   The tests are generated such that there is **exactly one solution**.","hints":[],"similars":[{"title":"Two Sum","slug":"two-sum","difficulty":"Easy"},{"title":"Two Sum IV - Input is a BST","slug":"two-sum-iv-input-is-a-bst","difficulty":"Easy"},{"title":"Two Sum Less Than K","slug":"two-sum-less-than-k","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Binary Search","slug":"binary-search"}]},{"id":"189","slug":"rotate-array","title":"Rotate Array","difficulty":"Medium","content":"Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `0 <= k <= 105`\n\n**Follow up:**\n\n*   Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n*   Could you do it in-place with `O(1)` extra space?","hints":["The easiest solution would use additional memory and that is perfectly fine.","The actual trick comes when trying to solve this problem without using any additional memory. This means you need to use the original array somehow to move the elements around. Now, we can place each element in its original location and shift all the elements around it to adjust as that would be too costly and most likely will time out on larger input arrays.","One line of thought is based on reversing the array (or parts of it) to obtain the desired result. Think about how reversal might potentially help us out by using an example.","The other line of thought is a tad bit complicated but essentially it builds on the idea of placing each element in its original position while keeping track of the element originally in that position. Basically, at every step, we place an element in its rightful position and keep track of the element already there or the one being overwritten in an additional variable. We can't do this in one linear pass and the idea here is based on **cyclic-dependencies** between elements."],"similars":[{"title":"Rotate List","slug":"rotate-list","difficulty":"Medium"},{"title":"Reverse Words in a String II","slug":"reverse-words-in-a-string-ii","difficulty":"Medium"},{"title":"Make K-Subarray Sums Equal","slug":"make-k-subarray-sums-equal","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Math","slug":"math"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"198","slug":"house-robber","title":"House Robber","difficulty":"Medium","content":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`","hints":[],"similars":[{"title":"Maximum Product Subarray","slug":"maximum-product-subarray","difficulty":"Medium"},{"title":"House Robber II","slug":"house-robber-ii","difficulty":"Medium"},{"title":"Paint House","slug":"paint-house","difficulty":"Medium"},{"title":"Paint Fence","slug":"paint-fence","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"199","slug":"binary-tree-right-side-view","title":"Binary Tree Right Side View","difficulty":"Medium","content":"Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return _the values of the nodes you can see ordered from top to bottom_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)```javascript \nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1,null,3]\nOutput: [1,3]\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Populating Next Right Pointers in Each Node","slug":"populating-next-right-pointers-in-each-node","difficulty":"Medium"},{"title":"Boundary of Binary Tree","slug":"boundary-of-binary-tree","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"202","slug":"happy-number","title":"Happy Number","difficulty":"Easy","content":"Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.\n\n**Example 1:**\n\n```javascript \nInput: n = 19\nOutput: true\nExplanation:\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 2\nOutput: false\n```\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`","hints":[],"similars":[{"title":"Linked List Cycle","slug":"linked-list-cycle","difficulty":"Easy"},{"title":"Add Digits","slug":"add-digits","difficulty":"Easy"},{"title":"Ugly Number","slug":"ugly-number","difficulty":"Easy"},{"title":"Sum of Digits of String After Convert","slug":"sum-of-digits-of-string-after-convert","difficulty":"Easy"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Math","slug":"math"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"205","slug":"isomorphic-strings","title":"Isomorphic Strings","difficulty":"Easy","content":"Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n**Example 1:**\n\n```javascript \nInput: s = \"egg\", t = \"add\"\nOutput: true\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"foo\", t = \"bar\"\nOutput: false\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"paper\", t = \"title\"\nOutput: true\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.","hints":[],"similars":[{"title":"Word Pattern","slug":"word-pattern","difficulty":"Easy"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"}]},{"id":"206","slug":"reverse-linked-list","title":"Reverse Linked List","difficulty":"Easy","content":"Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)```javascript \nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)```javascript \nInput: head = [1,2]\nOutput: [2,1]\n```\n\n**Example 3:**\n\n```javascript \nInput: head = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n\n**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?","hints":[],"similars":[{"title":"Reverse Linked List II","slug":"reverse-linked-list-ii","difficulty":"Medium"},{"title":"Binary Tree Upside Down","slug":"binary-tree-upside-down","difficulty":"Medium"},{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Reverse Nodes in Even Length Groups","slug":"reverse-nodes-in-even-length-groups","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Recursion","slug":"recursion"}]},{"id":"221","slug":"maximal-square","title":"Maximal Square","difficulty":"Medium","content":"Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)```javascript \nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)```javascript \nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```\n\n**Example 3:**\n\n```javascript \nInput: matrix = [[\"0\"]]\nOutput: 0\n```\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.","hints":[],"similars":[{"title":"Maximal Rectangle","slug":"maximal-rectangle","difficulty":"Hard"},{"title":"Largest Plus Sign","slug":"largest-plus-sign","difficulty":"Medium"},{"title":"Count Artifacts That Can Be Extracted","slug":"count-artifacts-that-can-be-extracted","difficulty":"Medium"},{"title":"Stamping the Grid","slug":"stamping-the-grid","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Matrix","slug":"matrix"}]},{"id":"222","slug":"count-complete-tree-nodes","title":"Count Complete Tree Nodes","difficulty":"Easy","content":"Given the `root` of a **complete** binary tree, return the number of the nodes in the tree.\n\nAccording to **[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.\n\nDesign an algorithm that runs in less than `O(n)` time complexity.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)```javascript \nInput: root = [1,2,3,4,5,6]\nOutput: 6\n```\n\n**Example 2:**\n\n```javascript \nInput: root = []\nOutput: 0\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [1]\nOutput: 1\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5 * 104]`.\n*   `0 <= Node.val <= 5 * 104`\n*   The tree is guaranteed to be **complete**.","hints":[],"similars":[{"title":"Closest Binary Search Tree Value","slug":"closest-binary-search-tree-value","difficulty":"Easy"}],"tags":[{"name":"Binary Search","slug":"binary-search"},{"name":"Bit Manipulation","slug":"bit-manipulation"},{"name":"Tree","slug":"tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"226","slug":"invert-binary-tree","title":"Invert Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, invert the tree, and return _its root_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)```javascript \nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)```javascript \nInput: root = [2,1,3]\nOutput: [2,3,1]\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Reverse Odd Levels of Binary Tree","slug":"reverse-odd-levels-of-binary-tree","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"230","slug":"kth-smallest-element-in-a-bst","title":"Kth Smallest Element in a BST","difficulty":"Medium","content":"Given the `root` of a binary search tree, and an integer `k`, return _the_ `kth` _smallest value (**1-indexed**) of all the values of the nodes in the tree_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)```javascript \nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)```javascript \nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= k <= n <= 104`\n*   `0 <= Node.val <= 104`\n\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?","hints":["Try to utilize the property of a BST.","Try in-order traversal. (Credits to @chan13)","What if you could modify the BST node's structure?","The optimal runtime complexity is O(height of BST)."],"similars":[{"title":"Binary Tree Inorder Traversal","slug":"binary-tree-inorder-traversal","difficulty":"Easy"},{"title":"Second Minimum Node In a Binary Tree","slug":"second-minimum-node-in-a-binary-tree","difficulty":"Easy"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"236","slug":"lowest-common-ancestor-of-a-binary-tree","title":"Lowest Common Ancestor of a Binary Tree","difficulty":"Medium","content":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)```javascript \nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)```javascript \nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 105]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n*   `p` and `q` will exist in the tree.","hints":[],"similars":[{"title":"Lowest Common Ancestor of a Binary Search Tree","slug":"lowest-common-ancestor-of-a-binary-search-tree","difficulty":"Medium"},{"title":"Smallest Common Region","slug":"smallest-common-region","difficulty":"Medium"},{"title":"Find Players With Zero or One Losses","slug":"find-players-with-zero-or-one-losses","difficulty":"Medium"},{"title":"Lowest Common Ancestor of a Binary Tree II","slug":"lowest-common-ancestor-of-a-binary-tree-ii","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"238","slug":"product-of-array-except-self","title":"Product of Array Except Self","difficulty":"Medium","content":"Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```\n\n**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-30 <= nums[i] <= 30`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)","hints":[],"similars":[{"title":"Trapping Rain Water","slug":"trapping-rain-water","difficulty":"Hard"},{"title":"Maximum Product Subarray","slug":"maximum-product-subarray","difficulty":"Medium"},{"title":"Paint House II","slug":"paint-house-ii","difficulty":"Hard"},{"title":"Minimum Difference in Sums After Removal of Elements","slug":"minimum-difference-in-sums-after-removal-of-elements","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Prefix Sum","slug":"prefix-sum"}]},{"id":"290","slug":"word-pattern","title":"Word Pattern","difficulty":"Easy","content":"Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.\n\n**Example 1:**\n\n```javascript \nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\n```\n\n**Example 2:**\n\n```javascript \nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\n```\n\n**Example 3:**\n\n```javascript \nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false\n```\n\n**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.","hints":[],"similars":[{"title":"Isomorphic Strings","slug":"isomorphic-strings","difficulty":"Easy"},{"title":"Word Pattern II","slug":"word-pattern-ii","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"}]},{"id":"300","slug":"longest-increasing-subsequence","title":"Longest Increasing Subsequence","difficulty":"Medium","content":"Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.\n\n**Example 1:**\n\n```javascript \nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?","hints":[],"similars":[{"title":"Increasing Triplet Subsequence","slug":"increasing-triplet-subsequence","difficulty":"Medium"},{"title":"Russian Doll Envelopes","slug":"russian-doll-envelopes","difficulty":"Hard"},{"title":"Maximum Length of Pair Chain","slug":"maximum-length-of-pair-chain","difficulty":"Medium"},{"title":"Number of Longest Increasing Subsequence","slug":"number-of-longest-increasing-subsequence","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Binary Search","slug":"binary-search"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"303","slug":"range-sum-query-immutable","title":"Range Sum Query - Immutable","difficulty":"Easy","content":"Given an integer array `nums`, handle multiple queries of the following type:\n\n1.  Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n*   `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n*   `int sumRange(int left, int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).\n\n**Example 1:**\n\n```javascript \nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-105 <= nums[i] <= 105`\n*   `0 <= left <= right < nums.length`\n*   At most `104` calls will be made to `sumRange`.","hints":[],"similars":[{"title":"Range Sum Query 2D - Immutable","slug":"range-sum-query-2d-immutable","difficulty":"Medium"},{"title":"Range Sum Query - Mutable","slug":"range-sum-query-mutable","difficulty":"Medium"},{"title":"Maximum Size Subarray Sum Equals k","slug":"maximum-size-subarray-sum-equals-k","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Design","slug":"design"},{"name":"Prefix Sum","slug":"prefix-sum"}]},{"id":"322","slug":"coin-change","title":"Coin Change","difficulty":"Medium","content":"You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n\n```javascript \nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n```\n\n**Example 2:**\n\n```javascript \nInput: coins = [2], amount = 3\nOutput: -1\n```\n\n**Example 3:**\n\n```javascript \nInput: coins = [1], amount = 0\nOutput: 0\n```\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`","hints":[],"similars":[{"title":"Minimum Cost For Tickets","slug":"minimum-cost-for-tickets","difficulty":"Medium"},{"title":"Maximum Value of K Coins From Piles","slug":"maximum-value-of-k-coins-from-piles","difficulty":"Hard"},{"title":"Minimum Number of Operations to Convert Time","slug":"minimum-number-of-operations-to-convert-time","difficulty":"Easy"},{"title":"Minimum Cost to Split an Array","slug":"minimum-cost-to-split-an-array","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Breadth-First Search","slug":"breadth-first-search"}]},{"id":"334","slug":"increasing-triplet-subsequence","title":"Increasing Triplet Subsequence","difficulty":"Medium","content":"Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5 * 105`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?","hints":[],"similars":[{"title":"Longest Increasing Subsequence","slug":"longest-increasing-subsequence","difficulty":"Medium"},{"title":"Count Special Quadruplets","slug":"count-special-quadruplets","difficulty":"Easy"},{"title":"Count Good Triplets in an Array","slug":"count-good-triplets-in-an-array","difficulty":"Hard"},{"title":"Count Increasing Quadruplets","slug":"count-increasing-quadruplets","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Greedy","slug":"greedy"}]},{"id":"345","slug":"reverse-vowels-of-a-string","title":"Reverse Vowels of a String","difficulty":"Easy","content":"Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once.\n\n**Example 1:**\n\n```javascript \nInput: s = \"hello\"\nOutput: \"holle\"\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"leetcode\"\nOutput: \"leotcede\"\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consist of **printable ASCII** characters.","hints":[],"similars":[{"title":"Reverse String","slug":"reverse-string","difficulty":"Easy"},{"title":"Remove Vowels from a String","slug":"remove-vowels-from-a-string","difficulty":"Easy"},{"title":"Faulty Keyboard","slug":"faulty-keyboard","difficulty":"Easy"},{"title":"Sort Vowels in a String","slug":"sort-vowels-in-a-string","difficulty":"Medium"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"374","slug":"guess-number-higher-or-lower","title":"Guess Number Higher or Lower","difficulty":"Easy","content":"We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n```javascript \nInput: n = 10, pick = 6\nOutput: 6\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 1, pick = 1\nOutput: 1\n```\n\n**Example 3:**\n\n```javascript \nInput: n = 2, pick = 1\nOutput: 1\n```\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`","hints":[],"similars":[{"title":"First Bad Version","slug":"first-bad-version","difficulty":"Easy"},{"title":"Guess Number Higher or Lower II","slug":"guess-number-higher-or-lower-ii","difficulty":"Medium"},{"title":"Find K Closest Elements","slug":"find-k-closest-elements","difficulty":"Medium"}],"tags":[{"name":"Binary Search","slug":"binary-search"},{"name":"Interactive","slug":"interactive"}]},{"id":"392","slug":"is-subsequence","title":"Is Subsequence","difficulty":"Easy","content":"Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace\"` is a subsequence of `\"abcde\"` while `\"aec\"` is not).\n\n**Example 1:**\n\n```javascript \nInput: s = \"abc\", t = \"ahbgdc\"\nOutput: true\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"axc\", t = \"ahbgdc\"\nOutput: false\n```\n\n**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?","hints":[],"similars":[{"title":"Number of Matching Subsequences","slug":"number-of-matching-subsequences","difficulty":"Medium"},{"title":"Shortest Way to Form String","slug":"shortest-way-to-form-string","difficulty":"Medium"},{"title":"Append Characters to String to Make Subsequence","slug":"append-characters-to-string-to-make-subsequence","difficulty":"Medium"},{"title":"Make String a Subsequence Using Cyclic Increments","slug":"make-string-a-subsequence-using-cyclic-increments","difficulty":"Medium"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"437","slug":"path-sum-iii","title":"Path Sum III","difficulty":"Medium","content":"Given the `root` of a binary tree and an integer `targetSum`, return _the number of paths where the sum of the values along the path equals_ `targetSum`.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)```javascript \nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 1000]`.\n*   `-109 <= Node.val <= 109`\n*   `-1000 <= targetSum <= 1000`","hints":[],"similars":[{"title":"Path Sum","slug":"path-sum","difficulty":"Easy"},{"title":"Path Sum II","slug":"path-sum-ii","difficulty":"Medium"},{"title":"Path Sum IV","slug":"path-sum-iv","difficulty":"Medium"},{"title":"Longest Univalue Path","slug":"longest-univalue-path","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"443","slug":"string-compression","title":"String Compression","difficulty":"Medium","content":"Given an array of characters `chars`, compress it using the following algorithm:\n\nBegin with an empty string `s`. For each group of **consecutive repeating characters** in `chars`:\n\n*   If the group's length is `1`, append the character to `s`.\n*   Otherwise, append the character followed by the group's length.\n\nThe compressed string `s` **should not be returned separately**, but instead, be stored **in the input character array `chars`**. Note that group lengths that are `10` or longer will be split into multiple characters in `chars`.\n\nAfter you are done **modifying the input array,** return _the new length of the array_.\n\nYou must write an algorithm that uses only constant extra space.\n\n**Example 1:**\n\n```javascript \nInput: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\nOutput: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\nExplanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n```\n\n**Example 2:**\n\n```javascript \nInput: chars = [\"a\"]\nOutput: Return 1, and the first character of the input array should be: [\"a\"]\nExplanation: The only group is \"a\", which remains uncompressed since it's a single character.\n```\n\n**Example 3:**\n\n```javascript \nInput: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\nOutput: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\nExplanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".```\n\n**Constraints:**\n\n*   `1 <= chars.length <= 2000`\n*   `chars[i]` is a lowercase English letter, uppercase English letter, digit, or symbol.","hints":["How do you know if you are at the end of a consecutive group of characters?"],"similars":[{"title":"Count and Say","slug":"count-and-say","difficulty":"Medium"},{"title":"Encode and Decode Strings","slug":"encode-and-decode-strings","difficulty":"Medium"},{"title":"Design Compressed String Iterator","slug":"design-compressed-string-iterator","difficulty":"Easy"},{"title":"Decompress Run-Length Encoded List","slug":"decompress-run-length-encoded-list","difficulty":"Easy"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"523","slug":"continuous-subarray-sum","title":"Continuous Subarray Sum","difficulty":"Medium","content":"Given an integer array nums and an integer k, return `true` _if_ `nums` _has a **good subarray** or_ `false` _otherwise_.\n\nA **good subarray** is a subarray where:\n\n*   its length is **at least two**, and\n*   the sum of the elements of the subarray is a multiple of `k`.\n\n**Note** that:\n\n*   A **subarray** is a contiguous part of the array.\n*   An integer `x` is a multiple of `k` if there exists an integer `n` such that `x = n * k`. `0` is **always** a multiple of `k`.\n\n**Example 1:**\n\n```javascript \nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7  6 and 7 is an integer.\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`\n*   `0 <= sum(nums[i]) <= 231 - 1`\n*   `1 <= k <= 231 - 1`","hints":[],"similars":[{"title":"Subarray Sum Equals K","slug":"subarray-sum-equals-k","difficulty":"Medium"},{"title":"Minimum Number of Operations to Make Array Continuous","slug":"minimum-number-of-operations-to-make-array-continuous","difficulty":"Hard"},{"title":"Intervals Between Identical Elements","slug":"intervals-between-identical-elements","difficulty":"Medium"},{"title":"Apply Operations to Make All Array Elements Equal to Zero","slug":"apply-operations-to-make-all-array-elements-equal-to-zero","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"},{"name":"Math","slug":"math"},{"name":"Prefix Sum","slug":"prefix-sum"}]},{"id":"530","slug":"minimum-absolute-difference-in-bst","title":"Minimum Absolute Difference in BST","difficulty":"Easy","content":"Given the `root` of a Binary Search Tree (BST), return _the minimum absolute difference between the values of any two different nodes in the tree_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)```javascript \nInput: root = [4,2,6,1,3]\nOutput: 1\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)```javascript \nInput: root = [1,0,48,null,null,12,49]\nOutput: 1\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 104]`.\n*   `0 <= Node.val <= 105`\n\n**Note:** This question is the same as 783: [https://leetcode.com/problems/minimum-distance-between-bst-nodes/](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)","hints":[],"similars":[{"title":"K-diff Pairs in an Array","slug":"k-diff-pairs-in-an-array","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"563","slug":"binary-tree-tilt","title":"Binary Tree Tilt","difficulty":"Easy","content":"Given the `root` of a binary tree, return _the sum of every tree node's **tilt**._\n\nThe **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if the node does not have a right child.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg)```javascript \nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg)```javascript \nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n```\n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg)```javascript \nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`","hints":["Don't think too much, this is an easy problem. Take some small tree as an example.","Can a parent node use the values of its child nodes? How will you implement it?","May be recursion and tree traversal can help you in implementing.","What about postorder traversal, using values of left and right childs?"],"similars":[{"title":"Find All The Lonely Nodes","slug":"find-all-the-lonely-nodes","difficulty":"Easy"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"623","slug":"add-one-row-to-tree","title":"Add One Row to Tree","difficulty":"Medium","content":"Given the `root` of a binary tree and two integers `val` and `depth`, add a row of nodes with value `val` at the given depth `depth`.\n\nNote that the `root` node is at depth `1`.\n\nThe adding rule is:\n\n*   Given the integer `depth`, for each not null tree node `cur` at the depth `depth - 1`, create two tree nodes with value `val` as `cur`'s left subtree root and right subtree root.\n*   `cur`'s original left subtree should be the left subtree of the new left subtree root.\n*   `cur`'s original right subtree should be the right subtree of the new right subtree root.\n*   If `depth == 1` that means there is no depth `depth - 1` at all, then create a tree node with value `val` as the new root of the whole original tree, and the original tree is the new root's left subtree.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)```javascript \nInput: root = [4,2,6,3,1,5], val = 1, depth = 2\nOutput: [4,1,1,2,null,null,6,3,1,5]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg)```javascript \nInput: root = [4,2,null,3,1], val = 1, depth = 3\nOutput: [4,2,null,1,1,3,null,null,1]\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   The depth of the tree is in the range `[1, 104]`.\n*   `-100 <= Node.val <= 100`\n*   `-105 <= val <= 105`\n*   `1 <= depth <= the depth of tree + 1`","hints":[],"similars":[],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"637","slug":"average-of-levels-in-binary-tree","title":"Average of Levels in Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, return _the average value of the nodes on each level in the form of an array_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)```javascript \nInput: root = [3,9,20,15,7]\nOutput: [3.00000,14.50000,11.00000]\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-231 <= Node.val <= 231 - 1`","hints":[],"similars":[{"title":"Binary Tree Level Order Traversal","slug":"binary-tree-level-order-traversal","difficulty":"Medium"},{"title":"Binary Tree Level Order Traversal II","slug":"binary-tree-level-order-traversal-ii","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"643","slug":"maximum-average-subarray-i","title":"Maximum Average Subarray I","difficulty":"Easy","content":"You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,12,-5,-6,50,3], k = 4\nOutput: 12.75000\nExplanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [5], k = 1\nOutput: 5.00000\n```\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 105`\n*   `-104 <= nums[i] <= 104`","hints":[],"similars":[{"title":"Maximum Average Subarray II","slug":"maximum-average-subarray-ii","difficulty":"Hard"},{"title":"K Radius Subarray Averages","slug":"k-radius-subarray-averages","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Sliding Window","slug":"sliding-window"}]},{"id":"653","slug":"two-sum-iv-input-is-a-bst","title":"Two Sum IV - Input is a BST","difficulty":"Easy","content":"Given the `root` of a binary search tree and an integer `k`, return `true` _if there exist two elements in the BST such that their sum is equal to_ `k`, _or_ `false` _otherwise_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg)```javascript \nInput: root = [5,3,6,2,4,null,7], k = 9\nOutput: true\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg)```javascript \nInput: root = [5,3,6,2,4,null,7], k = 28\nOutput: false\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-104 <= Node.val <= 104`\n*   `root` is guaranteed to be a **valid** binary search tree.\n*   `-105 <= k <= 105`","hints":[],"similars":[{"title":"Two Sum","slug":"two-sum","difficulty":"Easy"},{"title":"Two Sum II - Input Array Is Sorted","slug":"two-sum-ii-input-array-is-sorted","difficulty":"Medium"},{"title":"Two Sum III - Data structure design","slug":"two-sum-iii-data-structure-design","difficulty":"Easy"},{"title":"Two Sum BSTs","slug":"two-sum-bsts","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"654","slug":"maximum-binary-tree","title":"Maximum Binary Tree","difficulty":"Medium","content":"You are given an integer array `nums` with no duplicates. A **maximum binary tree** can be built recursively from `nums` using the following algorithm:\n\n1.  Create a root node whose value is the maximum value in `nums`.\n2.  Recursively build the left subtree on the **subarray prefix** to the **left** of the maximum value.\n3.  Recursively build the right subtree on the **subarray suffix** to the **right** of the maximum value.\n\nReturn _the **maximum binary tree** built from_ `nums`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)```javascript \nInput: nums = [3,2,1,6,0,5]\nOutput: [6,3,5,null,2,0,null,null,1]\nExplanation: The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)```javascript \nInput: nums = [3,2,1]\nOutput: [3,null,2,null,1]\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n*   All integers in `nums` are **unique**.","hints":[],"similars":[{"title":"Maximum Binary Tree II","slug":"maximum-binary-tree-ii","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Divide and Conquer","slug":"divide-and-conquer"},{"name":"Stack","slug":"stack"},{"name":"Tree","slug":"tree"},{"name":"Monotonic Stack","slug":"monotonic-stack"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"655","slug":"print-binary-tree","title":"Print Binary Tree","difficulty":"Medium","content":"Given the `root` of a binary tree, construct a **0-indexed** `m x n` string matrix `res` that represents a **formatted layout** of the tree. The formatted layout matrix should be constructed using the following rules:\n\n*   The **height** of the tree is `height` and the number of rows `m` should be equal to `height + 1`.\n*   The number of columns `n` should be equal to `2height+1 - 1`.\n*   Place the **root node** in the **middle** of the **top row** (more formally, at location `res[0][(n-1)/2]`).\n*   For each node that has been placed in the matrix at position `res[r][c]`, place its **left child** at `res[r+1][c-2height-r-1]` and its **right child** at `res[r+1][c+2height-r-1]`.\n*   Continue this process until all the nodes in the tree have been placed.\n*   Any empty cells should contain the empty string `\"\"`.\n\nReturn _the constructed matrix_ `res`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg)```javascript \nInput: root = [1,2]\nOutput: \n[[\"\",\"1\",\"\"],\n [\"2\",\"\",\"\"]]\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg)```javascript \nInput: root = [1,2,3,null,4]\nOutput: \n[[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n [\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n [\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 210]`.\n*   `-99 <= Node.val <= 99`\n*   The depth of the tree will be in the range `[1, 10]`.","hints":[],"similars":[],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"680","slug":"valid-palindrome-ii","title":"Valid Palindrome II","difficulty":"Easy","content":"Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_.\n\n**Example 1:**\n\n```javascript \nInput: s = \"aba\"\nOutput: true\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"abca\"\nOutput: true\nExplanation: You could delete the character 'c'.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"abc\"\nOutput: false\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.","hints":[],"similars":[{"title":"Valid Palindrome","slug":"valid-palindrome","difficulty":"Easy"},{"title":"Valid Palindrome III","slug":"valid-palindrome-iii","difficulty":"Hard"},{"title":"Valid Palindrome IV","slug":"valid-palindrome-iv","difficulty":"Medium"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"},{"name":"Greedy","slug":"greedy"}]},{"id":"747","slug":"min-cost-climbing-stairs","title":"Min Cost Climbing Stairs","difficulty":"Easy","content":"You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn _the minimum cost to reach the top of the floor_.\n\n**Example 1:**\n\n```javascript \nInput: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n```\n\n**Example 2:**\n\n```javascript \nInput: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n```\n\n**Constraints:**\n\n*   `2 <= cost.length <= 1000`\n*   `0 <= cost[i] <= 999`","hints":["Build an array dp where dp\\[i\\] is the minimum cost to climb to the top starting from the ith staircase.","Assuming we have n staircase labeled from 0 to n - 1 and assuming the top is n, then dp\\[n\\] = 0, marking that if you are at the top, the cost is 0.","Now, looping from n - 1 to 0, the dp\\[i\\] = cost\\[i\\] + min(dp\\[i + 1\\], dp\\[i + 2\\]). The answer will be the minimum of dp\\[0\\] and dp\\[1\\]"],"similars":[{"title":"Climbing Stairs","slug":"climbing-stairs","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"904","slug":"leaf-similar-trees","title":"Leaf-Similar Trees","difficulty":"Easy","content":"Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a **leaf value sequence**_._\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png)\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\nTwo binary trees are considered _leaf-similar_ if their leaf value sequence is the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg)```javascript \nInput: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\nOutput: true\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg)```javascript \nInput: root1 = [1,2,3], root2 = [1,3,2]\nOutput: false\n```\n\n**Constraints:**\n\n*   The number of nodes in each tree will be in the range `[1, 200]`.\n*   Both of the given trees will have values in the range `[0, 200]`.","hints":[],"similars":[],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"967","slug":"minimum-falling-path-sum","title":"Minimum Falling Path Sum","difficulty":"Medium","content":"Given an `n x n` array of integers `matrix`, return _the **minimum sum** of any **falling path** through_ `matrix`.\n\nA **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg)```javascript \nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]]\nOutput: 13\nExplanation: There are two falling paths with a minimum sum as shown.\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg)```javascript \nInput: matrix = [[-19,57],[-40,-5]]\nOutput: -59\nExplanation: The falling path with a minimum sum is shown.\n```\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 100`\n*   `-100 <= matrix[i][j] <= 100`","hints":[],"similars":[{"title":"Minimum Falling Path Sum II","slug":"minimum-falling-path-sum-ii","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Matrix","slug":"matrix"}]},{"id":"1046","slug":"max-consecutive-ones-iii","title":"Max Consecutive Ones III","difficulty":"Medium","content":"Given a binary array `nums` and an integer `k`, return _the maximum number of consecutive_ `1`_'s in the array if you can flip at most_ `k` `0`'s.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.```\n\n**Example 2:**\n\n```javascript \nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.\n*   `0 <= k <= nums.length`","hints":["One thing's for sure, we will only flip a zero if it extends an existing window of 1s. Otherwise, there's no point in doing it, right? Think Sliding Window!","Since we know this problem can be solved using the sliding window construct, we might as well focus in that direction for hints. Basically, in a given window, we can never have > K zeros, right?","We don't have a fixed size window in this case. The window size can grow and shrink depending upon the number of zeros we have (we don't actually have to flip the zeros here!).","The way to shrink or expand a window would be based on the number of zeros that can still be flipped and so on."],"similars":[{"title":"Longest Substring with At Most K Distinct Characters","slug":"longest-substring-with-at-most-k-distinct-characters","difficulty":"Medium"},{"title":"Longest Repeating Character Replacement","slug":"longest-repeating-character-replacement","difficulty":"Medium"},{"title":"Max Consecutive Ones","slug":"max-consecutive-ones","difficulty":"Easy"},{"title":"Max Consecutive Ones II","slug":"max-consecutive-ones-ii","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Binary Search","slug":"binary-search"},{"name":"Sliding Window","slug":"sliding-window"},{"name":"Prefix Sum","slug":"prefix-sum"}]},{"id":"1146","slug":"greatest-common-divisor-of-strings","title":"Greatest Common Divisor of Strings","difficulty":"Easy","content":"For two strings `s` and `t`, we say \"`t` divides `s`\" if and only if `s = t + ... + t` (i.e., `t` is concatenated with itself one or more times).\n\nGiven two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`.\n\n**Example 1:**\n\n```javascript \nInput: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"\n```\n\n**Example 2:**\n\n```javascript \nInput: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"\n```\n\n**Example 3:**\n\n```javascript \nInput: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"\n```\n\n**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of English uppercase letters.","hints":["The greatest common divisor must be a prefix of each string, so we can try all prefixes."],"similars":[{"title":"Find Greatest Common Divisor of Array","slug":"find-greatest-common-divisor-of-array","difficulty":"Easy"},{"title":"Smallest Even Multiple","slug":"smallest-even-multiple","difficulty":"Easy"}],"tags":[{"name":"Math","slug":"math"},{"name":"String","slug":"string"}]},{"id":"1236","slug":"n-th-tribonacci-number","title":"N-th Tribonacci Number","difficulty":"Easy","content":"The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.\n\n**Example 1:**\n\n```javascript \nInput: n = 4\nOutput: 4\nExplanation:\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 25\nOutput: 1389537\n```\n\n**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.","hints":["Make an array F of length 38, and set F\\[0\\] = 0, F\\[1\\] = F\\[2\\] = 1.","Now write a loop where you set F\\[n+3\\] = F\\[n\\] + F\\[n+1\\] + F\\[n+2\\], and return F\\[n\\]."],"similars":[{"title":"Climbing Stairs","slug":"climbing-stairs","difficulty":"Easy"},{"title":"Fibonacci Number","slug":"fibonacci-number","difficulty":"Easy"}],"tags":[{"name":"Math","slug":"math"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Memoization","slug":"memoization"}]},{"id":"1392","slug":"find-the-difference-of-two-arrays","title":"Find the Difference of Two Arrays","difficulty":"Easy","content":"Given two **0-indexed** integer arrays `nums1` and `nums2`, return _a list_ `answer` _of size_ `2` _where:_\n\n*   `answer[0]` _is a list of all **distinct** integers in_ `nums1` _which are **not** present in_ `nums2`_._\n*   `answer[1]` _is a list of all **distinct** integers in_ `nums2` _which are **not** present in_ `nums1`.\n\n**Note** that the integers in the lists may be returned in **any** order.\n\n**Example 1:**\n\n```javascript \nInput: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].```\n\n**Example 2:**\n\n```javascript \nInput: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n```\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `-1000 <= nums1[i], nums2[i] <= 1000`","hints":["For each integer in nums1, check if it exists in nums2.","Do the same for each integer in nums2."],"similars":[{"title":"Intersection of Two Arrays","slug":"intersection-of-two-arrays","difficulty":"Easy"},{"title":"Intersection of Two Arrays II","slug":"intersection-of-two-arrays-ii","difficulty":"Easy"},{"title":"Intersection of Multiple Arrays","slug":"intersection-of-multiple-arrays","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"}]},{"id":"1474","slug":"longest-zigzag-path-in-a-binary-tree","title":"Longest ZigZag Path in a Binary Tree","difficulty":"Medium","content":"You are given the `root` of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n*   Choose **any** node in the binary tree and a direction (right or left).\n*   If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n*   Change the direction from right to left or from left to right.\n*   Repeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn _the longest **ZigZag** path contained in that tree_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png)```javascript \nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png)```javascript \nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [1]\nOutput: 0\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 5 * 104]`.\n*   `1 <= Node.val <= 100`","hints":["Create this function maxZigZag(node, direction) maximum zigzag given a node and direction (right or left)."],"similars":[],"tags":[{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"1544","slug":"count-good-nodes-in-binary-tree","title":"Count Good Nodes in Binary Tree","difficulty":"Medium","content":"Given a binary tree `root`, a node _X_ in the tree is named **good** if in the path from root to _X_ there are no nodes with a value _greater than_ X.\n\nReturn the number of **good** nodes in the binary tree.\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)**\n\n```javascript \nInput: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.```\n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)**\n\n```javascript \nInput: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.```\n\n**Example 3:**\n\n```javascript \nInput: root = [1]\nOutput: 1\nExplanation: Root is considered as good.```\n\n**Constraints:**\n\n*   The number of nodes in the binary tree is in the range `[1, 10^5]`.\n*   Each node's value is between `[-10^4, 10^4]`.","hints":["Use DFS (Depth First Search) to traverse the tree, and constantly keep track of the current path maximum."],"similars":[],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"1567","slug":"maximum-number-of-vowels-in-a-substring-of-given-length","title":"Maximum Number of Vowels in a Substring of Given Length","difficulty":"Medium","content":"Given a string `s` and an integer `k`, return _the maximum number of vowel letters in any substring of_ `s` _with length_ `k`.\n\n**Vowel letters** in English are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`.\n\n**Example 1:**\n\n```javascript \nInput: s = \"abciiidef\", k = 3\nOutput: 3\nExplanation: The substring \"iii\" contains 3 vowel letters.\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"aeiou\", k = 2\nOutput: 2\nExplanation: Any substring of length 2 contains 2 vowels.\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"leetcode\", k = 3\nOutput: 2\nExplanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels.\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.\n*   `1 <= k <= s.length`","hints":["Keep a window of size k and maintain the number of vowels in it.","Keep moving the window and update the number of vowels while moving. Answer is max number of vowels of any window."],"similars":[{"title":"Maximum White Tiles Covered by a Carpet","slug":"maximum-white-tiles-covered-by-a-carpet","difficulty":"Medium"},{"title":"Minimum Recolors to Get K Consecutive Black Blocks","slug":"minimum-recolors-to-get-k-consecutive-black-blocks","difficulty":"Easy"},{"title":"Length of the Longest Alphabetical Continuous Substring","slug":"length-of-the-longest-alphabetical-continuous-substring","difficulty":"Medium"}],"tags":[{"name":"String","slug":"string"},{"name":"Sliding Window","slug":"sliding-window"}]},{"id":"1693","slug":"sum-of-all-odd-length-subarrays","title":"Sum of All Odd Length Subarrays","difficulty":"Easy","content":"Given an array of positive integers `arr`, return _the sum of all possible **odd-length subarrays** of_ `arr`.\n\nA **subarray** is a contiguous subsequence of the array.\n\n**Example 1:**\n\n```javascript \nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58```\n\n**Example 2:**\n\n```javascript \nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.```\n\n**Example 3:**\n\n```javascript \nInput: arr = [10,11,12]\nOutput: 66\n```\n\n**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= 1000`\n\n**Follow up:**\n\nCould you solve this problem in O(n) time complexity?","hints":["You can brute force – try every (i,j) pair, and if the length is odd, go through and add the sum to the answer."],"similars":[{"title":"Sum of Squares of Special Elements ","slug":"sum-of-squares-of-special-elements","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Math","slug":"math"},{"name":"Prefix Sum","slug":"prefix-sum"}]},{"id":"1798","slug":"max-number-of-k-sum-pairs","title":"Max Number of K-Sum Pairs","difficulty":"Medium","content":"You are given an integer array `nums` and an integer `k`.\n\nIn one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array.\n\nReturn _the maximum number of operations you can perform on the array_.\n\n**Example 1:**\n\n```javascript \nInput: nums = [1,2,3,4], k = 5\nOutput: 2\nExplanation: Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.```\n\n**Example 2:**\n\n```javascript \nInput: nums = [3,1,3,4,3], k = 6\nOutput: 1\nExplanation: Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3's, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation.```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 109`\n*   `1 <= k <= 109`","hints":["The abstract problem asks to count the number of disjoint pairs with a given sum k.","For each possible value x, it can be paired up with k - x.","The number of such pairs equals to min(count(x), count(k-x)), unless that x = k / 2, where the number of such pairs will be floor(count(x) / 2)."],"similars":[{"title":"Two Sum","slug":"two-sum","difficulty":"Easy"},{"title":"Count Good Meals","slug":"count-good-meals","difficulty":"Medium"},{"title":"Divide Players Into Teams of Equal Skill","slug":"divide-players-into-teams-of-equal-skill","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Sorting","slug":"sorting"}]},{"id":"1894","slug":"merge-strings-alternately","title":"Merge Strings Alternately","difficulty":"Easy","content":"You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\nReturn _the merged string._\n\n**Example 1:**\n\n```javascript \nInput: word1 = \"abc\", word2 = \"pqr\"\nOutput: \"apbqcr\"\nExplanation: The merged string will be merged as so:\nword1:  a   b   c\nword2:    p   q   r\nmerged: a p b q c r\n```\n\n**Example 2:**\n\n```javascript \nInput: word1 = \"ab\", word2 = \"pqrs\"\nOutput: \"apbqrs\"\nExplanation: Notice that as word2 is longer, \"rs\" is appended to the end.\nword1:  a   b \nword2:    p   q   r   s\nmerged: a p b q   r   s\n```\n\n**Example 3:**\n\n```javascript \nInput: word1 = \"abcd\", word2 = \"pq\"\nOutput: \"apbqcd\"\nExplanation: Notice that as word1 is longer, \"cd\" is appended to the end.\nword1:  a   b   c   d\nword2:    p   q \nmerged: a p b q c   d\n```\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 100`\n*   `word1` and `word2` consist of lowercase English letters.","hints":["Use two pointers, one pointer for each string. Alternately choose the character from each pointer, and move the pointer upwards."],"similars":[{"title":"Zigzag Iterator","slug":"zigzag-iterator","difficulty":"Medium"},{"title":"Minimum Additions to Make Valid String","slug":"minimum-additions-to-make-valid-string","difficulty":"Medium"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"2265","slug":"partition-array-according-to-given-pivot","title":"Partition Array According to Given Pivot","difficulty":"Medium","content":"You are given a **0-indexed** integer array `nums` and an integer `pivot`. Rearrange `nums` such that the following conditions are satisfied:\n\n*   Every element less than `pivot` appears **before** every element greater than `pivot`.\n*   Every element equal to `pivot` appears **in between** the elements less than and greater than `pivot`.\n*   The **relative order** of the elements less than `pivot` and the elements greater than `pivot` is maintained.\n    *   More formally, consider every `pi`, `pj` where `pi` is the new position of the `ith` element and `pj` is the new position of the `jth` element. For elements less than `pivot`, if `i < j` and `nums[i] < pivot` and `nums[j] < pivot`, then `pi < pj`. Similarly for elements greater than `pivot`, if `i < j` and `nums[i] > pivot` and `nums[j] > pivot`, then `pi < pj`.\n\nReturn `nums` _after the rearrangement._\n\n**Example 1:**\n\n```javascript \nInput: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-106 <= nums[i] <= 106`\n*   `pivot` equals to an element of `nums`.","hints":["Could you put the elements smaller than the pivot and greater than the pivot in a separate list as in the sequence that they occur?","With the separate lists generated, could you then generate the result?"],"similars":[{"title":"Partition List","slug":"partition-list","difficulty":"Medium"},{"title":"Rearrange Array Elements by Sign","slug":"rearrange-array-elements-by-sign","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Two Pointers","slug":"two-pointers"},{"name":"Simulation","slug":"simulation"}]},{"id":"2728","slug":"sum-in-a-matrix","title":"Sum in a Matrix","difficulty":"Medium","content":"You are given a **0-indexed** 2D integer array `nums`. Initially, your score is `0`. Perform the following operations until the matrix becomes empty:\n\n1.  From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\n2.  Identify the highest number amongst all those removed in step 1. Add that number to your **score**.\n\nReturn _the final **score**._\n\n**Example 1:**\n\n```javascript \nInput: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\nOutput: 15\nExplanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [[1]]\nOutput: 1\nExplanation: We remove 1 and add it to the answer. We return 1.```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 300`\n*   `1 <= nums[i].length <= 500`\n*   `0 <= nums[i][j] <= 103`","hints":["Sort the numbers in each row in decreasing order.","The answer is the summation of the max number in every column after sorting the rows."],"similars":[],"tags":[{"name":"Array","slug":"array"},{"name":"Sorting","slug":"sorting"},{"name":"Heap (Priority Queue)","slug":"heap-priority-queue"},{"name":"Matrix","slug":"matrix"},{"name":"Simulation","slug":"simulation"}]}]