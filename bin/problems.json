[{"id":"1","slug":"two-sum","title":"Two Sum","difficulty":"Easy","content":"Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n\n```javascript \nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n```\n\n**Example 3:**\n\n```javascript \nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n```\n\n**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?","hints":["A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.","So, if we fix one of the numbers, say `x`, we have to scan the entire array to find the next number `y` which is `value - x` where value is the input parameter. Can we change our array somehow so that this search becomes faster?","The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"],"similars":[{"title":"3Sum","slug":"3sum","difficulty":"Medium"},{"title":"4Sum","slug":"4sum","difficulty":"Medium"},{"title":"Two Sum II - Input Array Is Sorted","slug":"two-sum-ii-input-array-is-sorted","difficulty":"Medium"},{"title":"Two Sum III - Data structure design","slug":"two-sum-iii-data-structure-design","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"}]},{"id":"9","slug":"palindrome-number","title":"Palindrome Number","difficulty":"Easy","content":"Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.\n\n**Example 1:**\n\n```javascript \nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n```\n\n**Example 2:**\n\n```javascript \nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n```\n\n**Example 3:**\n\n```javascript \nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n```\n\n**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**Follow up:** Could you solve it without converting the integer to a string?","hints":["Beware of overflow when you reverse the integer."],"similars":[{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Find Palindrome With Fixed Length","slug":"find-palindrome-with-fixed-length","difficulty":"Medium"},{"title":"Strictly Palindromic Number","slug":"strictly-palindromic-number","difficulty":"Medium"},{"title":"  Count Symmetric Integers","slug":"count-symmetric-integers","difficulty":"Easy"}],"tags":[{"name":"Math","slug":"math"}]},{"id":"20","slug":"valid-parentheses","title":"Valid Parentheses","difficulty":"Easy","content":"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.\n\n**Example 1:**\n\n```javascript \nInput: s = \"()\"\nOutput: true\n\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"()[]{}\"\nOutput: true\n\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \"(]\"\nOutput: false\n\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.","hints":["Use a stack of characters.","When you encounter an opening bracket, push it to the top of the stack.","When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."],"similars":[{"title":"Generate Parentheses","slug":"generate-parentheses","difficulty":"Medium"},{"title":"Longest Valid Parentheses","slug":"longest-valid-parentheses","difficulty":"Hard"},{"title":"Remove Invalid Parentheses","slug":"remove-invalid-parentheses","difficulty":"Hard"},{"title":"Check If Word Is Valid After Substitutions","slug":"check-if-word-is-valid-after-substitutions","difficulty":"Medium"}],"tags":[{"name":"String","slug":"string"},{"name":"Stack","slug":"stack"}]},{"id":"21","slug":"merge-two-sorted-lists","title":"Merge Two Sorted Lists","difficulty":"Easy","content":"You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n```javascript \nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\n```\n\n**Example 2:**\n\n```javascript \nInput: list1 = [], list2 = []\nOutput: []\n\n```\n\n**Example 3:**\n\n```javascript \nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n```\n\n**Constraints:**\n\n*   The number of nodes in both lists is in the range `[0, 50]`.\n*   `-100 <= Node.val <= 100`\n*   Both `list1` and `list2` are sorted in **non-decreasing** order.","hints":[],"similars":[{"title":"Merge k Sorted Lists","slug":"merge-k-sorted-lists","difficulty":"Hard"},{"title":"Merge Sorted Array","slug":"merge-sorted-array","difficulty":"Easy"},{"title":"Sort List","slug":"sort-list","difficulty":"Medium"},{"title":"Shortest Word Distance II","slug":"shortest-word-distance-ii","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Recursion","slug":"recursion"}]},{"id":"70","slug":"climbing-stairs","title":"Climbing Stairs","difficulty":"Easy","content":"You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n\n```javascript \nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n```\n\n**Example 2:**\n\n```javascript \nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n```\n\n**Constraints:**\n\n*   `1 <= n <= 45`","hints":["To reach nth step, what could have been your previous steps? (Think about the step sizes)"],"similars":[{"title":"Min Cost Climbing Stairs","slug":"min-cost-climbing-stairs","difficulty":"Easy"},{"title":"Fibonacci Number","slug":"fibonacci-number","difficulty":"Easy"},{"title":"N-th Tribonacci Number","slug":"n-th-tribonacci-number","difficulty":"Easy"},{"title":"Minimum Rounds to Complete All Tasks","slug":"minimum-rounds-to-complete-all-tasks","difficulty":"Medium"}],"tags":[{"name":"Math","slug":"math"},{"name":"Dynamic Programming","slug":"dynamic-programming"},{"name":"Memoization","slug":"memoization"}]},{"id":"104","slug":"maximum-depth-of-binary-tree","title":"Maximum Depth of Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)\n```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1,null,2]\nOutput: 2\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Balanced Binary Tree","slug":"balanced-binary-tree","difficulty":"Easy"},{"title":"Minimum Depth of Binary Tree","slug":"minimum-depth-of-binary-tree","difficulty":"Easy"},{"title":"Maximum Depth of N-ary Tree","slug":"maximum-depth-of-n-ary-tree","difficulty":"Easy"},{"title":"Time Needed to Inform All Employees","slug":"time-needed-to-inform-all-employees","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"110","slug":"balanced-binary-tree","title":"Balanced Binary Tree","difficulty":"Easy","content":"Given a binary tree, determine if it is **height-balanced**.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n```javascript \nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n```javascript \nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: true\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 5000]`.\n*   `-104 <= Node.val <= 104`","hints":[],"similars":[{"title":"Maximum Depth of Binary Tree","slug":"maximum-depth-of-binary-tree","difficulty":"Easy"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"121","slug":"best-time-to-buy-and-sell-stock","title":"Best Time to Buy and Sell Stock","difficulty":"Easy","content":"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n\n**Example 1:**\n\n```javascript \nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n```\n\n**Example 2:**\n\n```javascript \nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n```\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`","hints":[],"similars":[{"title":"Maximum Subarray","slug":"maximum-subarray","difficulty":"Medium"},{"title":"Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-ii","difficulty":"Medium"},{"title":"Best Time to Buy and Sell Stock III","slug":"best-time-to-buy-and-sell-stock-iii","difficulty":"Hard"},{"title":"Best Time to Buy and Sell Stock IV","slug":"best-time-to-buy-and-sell-stock-iv","difficulty":"Hard"}],"tags":[{"name":"Array","slug":"array"},{"name":"Dynamic Programming","slug":"dynamic-programming"}]},{"id":"125","slug":"valid-palindrome","title":"Valid Palindrome","difficulty":"Easy","content":"A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n**Example 1:**\n\n```javascript \nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\n```\n\n**Example 3:**\n\n```javascript \nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.","hints":[],"similars":[{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Valid Palindrome II","slug":"valid-palindrome-ii","difficulty":"Easy"},{"title":"Maximum Product of the Length of Two Palindromic Subsequences","slug":"maximum-product-of-the-length-of-two-palindromic-subsequences","difficulty":"Medium"},{"title":"Find First Palindromic String in the Array","slug":"find-first-palindromic-string-in-the-array","difficulty":"Easy"}],"tags":[{"name":"Two Pointers","slug":"two-pointers"},{"name":"String","slug":"string"}]},{"id":"141","slug":"linked-list-cycle","title":"Linked List Cycle","difficulty":"Easy","content":"Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n```javascript \nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n```javascript \nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\n```\n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n```javascript \nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\n```\n\n**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?","hints":[],"similars":[{"title":"Linked List Cycle II","slug":"linked-list-cycle-ii","difficulty":"Medium"},{"title":"Happy Number","slug":"happy-number","difficulty":"Easy"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"Linked List","slug":"linked-list"},{"name":"Two Pointers","slug":"two-pointers"}]},{"id":"169","slug":"majority-element","title":"Majority Element","difficulty":"Easy","content":"Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.\n\n**Example 1:**\n\n```javascript \nInput: nums = [3,2,3]\nOutput: 3\n\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n\n```\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?","hints":[],"similars":[{"title":"Majority Element II","slug":"majority-element-ii","difficulty":"Medium"},{"title":"Check If a Number Is Majority Element in a Sorted Array","slug":"check-if-a-number-is-majority-element-in-a-sorted-array","difficulty":"Easy"},{"title":"Most Frequent Even Element","slug":"most-frequent-even-element","difficulty":"Easy"},{"title":"Minimum Index of a Valid Split","slug":"minimum-index-of-a-valid-split","difficulty":"Medium"}],"tags":[{"name":"Array","slug":"array"},{"name":"Hash Table","slug":"hash-table"},{"name":"Divide and Conquer","slug":"divide-and-conquer"},{"name":"Sorting","slug":"sorting"},{"name":"Counting","slug":"counting"}]},{"id":"206","slug":"reverse-linked-list","title":"Reverse Linked List","difficulty":"Easy","content":"Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n```javascript \nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n```javascript \nInput: head = [1,2]\nOutput: [2,1]\n\n```\n\n**Example 3:**\n\n```javascript \nInput: head = []\nOutput: []\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is the range `[0, 5000]`.\n*   `-5000 <= Node.val <= 5000`\n\n**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?","hints":[],"similars":[{"title":"Reverse Linked List II","slug":"reverse-linked-list-ii","difficulty":"Medium"},{"title":"Binary Tree Upside Down","slug":"binary-tree-upside-down","difficulty":"Medium"},{"title":"Palindrome Linked List","slug":"palindrome-linked-list","difficulty":"Easy"},{"title":"Reverse Nodes in Even Length Groups","slug":"reverse-nodes-in-even-length-groups","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Recursion","slug":"recursion"}]},{"id":"226","slug":"invert-binary-tree","title":"Invert Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, invert the tree, and return _its root_.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n```javascript \nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n```javascript \nInput: root = [2,1,3]\nOutput: [2,3,1]\n\n```\n\n**Example 3:**\n\n```javascript \nInput: root = []\nOutput: []\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 100]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Reverse Odd Levels of Binary Tree","slug":"reverse-odd-levels-of-binary-tree","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Breadth-First Search","slug":"breadth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"235","slug":"lowest-common-ancestor-of-a-binary-search-tree","title":"Lowest Common Ancestor of a Binary Search Tree","difficulty":"Medium","content":"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)\n```javascript \nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)\n```javascript \nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\n```\n\n**Example 3:**\n\n```javascript \nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 105]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `p != q`\n*   `p` and `q` will exist in the BST.","hints":[],"similars":[{"title":"Lowest Common Ancestor of a Binary Tree","slug":"lowest-common-ancestor-of-a-binary-tree","difficulty":"Medium"},{"title":"Smallest Common Region","slug":"smallest-common-region","difficulty":"Medium"},{"title":"Lowest Common Ancestor of a Binary Tree II","slug":"lowest-common-ancestor-of-a-binary-tree-ii","difficulty":"Medium"},{"title":"Lowest Common Ancestor of a Binary Tree III","slug":"lowest-common-ancestor-of-a-binary-tree-iii","difficulty":"Medium"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Search Tree","slug":"binary-search-tree"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"242","slug":"valid-anagram","title":"Valid Anagram","difficulty":"Easy","content":"Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n**Example 1:**\n\n```javascript \nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"rat\", t = \"car\"\nOutput: false\n\n```\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?","hints":[],"similars":[{"title":"Group Anagrams","slug":"group-anagrams","difficulty":"Medium"},{"title":"Palindrome Permutation","slug":"palindrome-permutation","difficulty":"Easy"},{"title":"Find All Anagrams in a String","slug":"find-all-anagrams-in-a-string","difficulty":"Medium"},{"title":"Find Resultant Array After Removing Anagrams","slug":"find-resultant-array-after-removing-anagrams","difficulty":"Easy"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Sorting","slug":"sorting"}]},{"id":"383","slug":"ransom-note","title":"Ransom Note","difficulty":"Easy","content":"Given two strings `ransomNote` and `magazine`, return `true` _if_ `ransomNote` _can be constructed by using the letters from_ `magazine` _and_ `false` _otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`.\n\n**Example 1:**\n\n```javascript \nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\n\n```\n\n**Example 2:**\n\n```javascript \nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\n\n```\n\n**Example 3:**\n\n```javascript \nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true\n\n```\n\n**Constraints:**\n\n*   `1 <= ransomNote.length, magazine.length <= 105`\n*   `ransomNote` and `magazine` consist of lowercase English letters.","hints":[],"similars":[{"title":"Stickers to Spell Word","slug":"stickers-to-spell-word","difficulty":"Hard"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Counting","slug":"counting"}]},{"id":"409","slug":"longest-palindrome","title":"Longest Palindrome","difficulty":"Easy","content":"Given a string `s` which consists of lowercase or uppercase letters, return the length of the **longest palindrome** that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa\"` is not considered a palindrome.\n\n**Example 1:**\n\n```javascript \nInput: s = \"abccccdd\"\nOutput: 7\nExplanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n\n```\n\n**Example 2:**\n\n```javascript \nInput: s = \"a\"\nOutput: 1\nExplanation: The longest palindrome that can be built is \"a\", whose length is 1.\n\n```\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.","hints":[],"similars":[{"title":"Palindrome Permutation","slug":"palindrome-permutation","difficulty":"Easy"},{"title":"Longest Palindrome by Concatenating Two Letter Words","slug":"longest-palindrome-by-concatenating-two-letter-words","difficulty":"Medium"},{"title":"Largest Palindromic Number","slug":"largest-palindromic-number","difficulty":"Medium"}],"tags":[{"name":"Hash Table","slug":"hash-table"},{"name":"String","slug":"string"},{"name":"Greedy","slug":"greedy"}]},{"id":"543","slug":"diameter-of-binary-tree","title":"Diameter of Binary Tree","difficulty":"Easy","content":"Given the `root` of a binary tree, return _the length of the **diameter** of the tree_.\n\nThe **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.\n\nThe **length** of a path between two nodes is represented by the number of edges between them.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\n```javascript \nInput: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\n```\n\n**Example 2:**\n\n```javascript \nInput: root = [1,2]\nOutput: 1\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-100 <= Node.val <= 100`","hints":[],"similars":[{"title":"Diameter of N-Ary Tree","slug":"diameter-of-n-ary-tree","difficulty":"Medium"},{"title":"Longest Path With Different Adjacent Characters","slug":"longest-path-with-different-adjacent-characters","difficulty":"Hard"}],"tags":[{"name":"Tree","slug":"tree"},{"name":"Depth-First Search","slug":"depth-first-search"},{"name":"Binary Tree","slug":"binary-tree"}]},{"id":"792","slug":"binary-search","title":"Binary Search","difficulty":"Easy","content":"Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n**Example 1:**\n\n```javascript \nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\n```\n\n**Example 2:**\n\n```javascript \nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\n```\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.","hints":[],"similars":[{"title":"Search in a Sorted Array of Unknown Size","slug":"search-in-a-sorted-array-of-unknown-size","difficulty":"Medium"},{"title":"Maximum Count of Positive Integer and Negative Integer","slug":"maximum-count-of-positive-integer-and-negative-integer","difficulty":"Easy"}],"tags":[{"name":"Array","slug":"array"},{"name":"Binary Search","slug":"binary-search"}]},{"id":"908","slug":"middle-of-the-linked-list","title":"Middle of the Linked List","difficulty":"Easy","content":"Given the `head` of a singly linked list, return _the middle node of the linked list_.\n\nIf there are two middle nodes, return **the second middle** node.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n```javascript \nInput: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n\n```\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n```javascript \nInput: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n\n```\n\n**Constraints:**\n\n*   The number of nodes in the list is in the range `[1, 100]`.\n*   `1 <= Node.val <= 100`","hints":[],"similars":[{"title":"Delete the Middle Node of a Linked List","slug":"delete-the-middle-node-of-a-linked-list","difficulty":"Medium"},{"title":"Maximum Twin Sum of a Linked List","slug":"maximum-twin-sum-of-a-linked-list","difficulty":"Medium"}],"tags":[{"name":"Linked List","slug":"linked-list"},{"name":"Two Pointers","slug":"two-pointers"}]}]